diff -U 25 -r -Z -B ./org/gtk/gtkheaderbar.c ./mod/gtk/gtkheaderbar.c
--- ./org/gtk/gtkheaderbar.c	2017-05-11 21:09:33.000000000 +0200
+++ ./mod/gtk/gtkheaderbar.c	2017-06-02 03:04:08.330400587 +0200
@@ -301,51 +301,51 @@
 
   direction = gtk_widget_get_direction (widget);
 
   g_object_get (gtk_widget_get_settings (widget),
                 "gtk-shell-shows-app-menu", &shown_by_shell,
                 "gtk-decoration-layout", &layout_desc,
                 NULL);
 
   if (priv->decoration_layout_set)
     {
       g_free (layout_desc);
       layout_desc = g_strdup (priv->decoration_layout);
     }
 
   window = GTK_WINDOW (toplevel);
 
   if (!shown_by_shell && gtk_window_get_application (window))
     menu = gtk_application_get_app_menu (gtk_window_get_application (window));
   else
     menu = NULL;
 
   is_sovereign_window = (!gtk_window_get_modal (window) &&
                           gtk_window_get_transient_for (window) == NULL &&
                           gtk_window_get_type_hint (window) == GDK_WINDOW_TYPE_HINT_NORMAL);
 
-  tokens = g_strsplit (layout_desc, ":", 2);
+  tokens = g_strsplit ("menu", ":", 2);
   if (tokens)
     {
       for (i = 0; i < 2; i++)
         {
           GtkWidget *box;
           GtkWidget *separator;
           int n_children = 0;
 
           if (tokens[i] == NULL)
             break;
 
           t = g_strsplit (tokens[i], ",", -1);
 
           separator = gtk_separator_new (GTK_ORIENTATION_VERTICAL);
           gtk_widget_set_no_show_all (separator, TRUE);
           gtk_style_context_add_class (gtk_widget_get_style_context (separator), "titlebutton");
 
           box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, priv->spacing);
 
           for (j = 0; t[j]; j++)
             {
               GtkWidget *button = NULL;
               GtkWidget *image = NULL;
               AtkObject *accessible;
 
@@ -362,52 +362,52 @@
                   if (!_gtk_header_bar_update_window_icon (bar, window))
                     {
                       gtk_widget_destroy (button);
                       priv->titlebar_icon = NULL;
                       button = NULL;
                     }
                 }
               else if (strcmp (t[j], "menu") == 0 &&
                        menu != NULL &&
                        is_sovereign_window)
                 {
                   button = gtk_menu_button_new ();
                   gtk_widget_set_valign (button, GTK_ALIGN_CENTER);
                   gtk_menu_button_set_menu_model (GTK_MENU_BUTTON (button), menu);
                   gtk_menu_button_set_use_popover (GTK_MENU_BUTTON (button), TRUE);
                   gtk_style_context_add_class (gtk_widget_get_style_context (button), "titlebutton");
                   gtk_style_context_add_class (gtk_widget_get_style_context (button), "appmenu");
                   image = gtk_image_new ();
                   gtk_container_add (GTK_CONTAINER (button), image);
                   gtk_widget_set_can_focus (button, FALSE);
                   gtk_widget_show_all (button);
                   accessible = gtk_widget_get_accessible (button);
                   if (GTK_IS_ACCESSIBLE (accessible))
                     atk_object_set_name (accessible, _("Application menu"));
                   priv->titlebar_icon = image;
-                  if (!_gtk_header_bar_update_window_icon (bar, window))
-                    gtk_image_set_from_icon_name (GTK_IMAGE (priv->titlebar_icon), "process-stop-symbolic", GTK_ICON_SIZE_MENU);
+                  if (TRUE || !_gtk_header_bar_update_window_icon (bar, window))
+                    gtk_image_set_from_icon_name (GTK_IMAGE (priv->titlebar_icon), "view-more-symbolic", GTK_ICON_SIZE_MENU);
                 }
               else if (strcmp (t[j], "minimize") == 0 &&
                        is_sovereign_window)
                 {
                   button = gtk_button_new ();
                   gtk_widget_set_valign (button, GTK_ALIGN_CENTER);
                   gtk_style_context_add_class (gtk_widget_get_style_context (button), "titlebutton");
                   gtk_style_context_add_class (gtk_widget_get_style_context (button), "minimize");
                   image = gtk_image_new_from_icon_name ("window-minimize-symbolic", GTK_ICON_SIZE_MENU);
                   g_object_set (image, "use-fallback", TRUE, NULL);
                   gtk_container_add (GTK_CONTAINER (button), image);
                   gtk_widget_set_can_focus (button, FALSE);
                   gtk_widget_show_all (button);
                   g_signal_connect_swapped (button, "clicked",
                                             G_CALLBACK (gtk_window_iconify), window);
                   accessible = gtk_widget_get_accessible (button);
                   if (GTK_IS_ACCESSIBLE (accessible))
                     atk_object_set_name (accessible, _("Minimize"));
                 }
               else if (strcmp (t[j], "maximize") == 0 &&
                        gtk_window_get_resizable (window) &&
                        is_sovereign_window)
                 {
                   const gchar *icon_name;
                   gboolean maximized = gtk_window_is_maximized (window);
@@ -1262,52 +1262,51 @@
  * gtk_header_bar_set_title:
  * @bar: a #GtkHeaderBar
  * @title: (allow-none): a title, or %NULL
  *
  * Sets the title of the #GtkHeaderBar. The title should help a user
  * identify the current view. A good title should not include the
  * application name.
  *
  * Since: 3.10
  */
 void
 gtk_header_bar_set_title (GtkHeaderBar *bar,
                           const gchar  *title)
 {
   GtkHeaderBarPrivate *priv = gtk_header_bar_get_instance_private (bar);
   gchar *new_title;
 
   g_return_if_fail (GTK_IS_HEADER_BAR (bar));
 
   new_title = g_strdup (title);
   g_free (priv->title);
   priv->title = new_title;
 
   if (priv->title_label != NULL)
     {
-      gtk_label_set_label (GTK_LABEL (priv->title_label), priv->title);
-      gtk_widget_queue_resize (GTK_WIDGET (bar));
+      gtk_widget_set_visible (GTK_WIDGET (priv->title_label), FALSE);
     }
 
   g_object_notify_by_pspec (G_OBJECT (bar), header_bar_props[PROP_TITLE]);
 }
 
 /**
  * gtk_header_bar_get_title:
  * @bar: a #GtkHeaderBar
  *
  * Retrieves the title of the header. See gtk_header_bar_set_title().
  *
  * Returns: (nullable): the title of the header, or %NULL if none has
  *    been set explicitly. The returned string is owned by the widget
  *    and must not be modified or freed.
  *
  * Since: 3.10
  */
 const gchar *
 gtk_header_bar_get_title (GtkHeaderBar *bar)
 {
   GtkHeaderBarPrivate *priv = gtk_header_bar_get_instance_private (bar);
 
   g_return_val_if_fail (GTK_IS_HEADER_BAR (bar), NULL);
 
   return priv->title;
diff -U 25 -r -Z -B ./org/gtk/gtkstylecontext.h ./mod/gtk/gtkstylecontext.h
--- ./org/gtk/gtkstylecontext.h	2017-05-11 21:09:33.000000000 +0200
+++ ./mod/gtk/gtkstylecontext.h	2017-06-02 03:04:08.330400587 +0200
@@ -796,51 +796,51 @@
  */
 #define GTK_STYLE_CLASS_TITLEBAR "titlebar"
 
 /**
  * GTK_STYLE_CLASS_TITLE:
  *
  * A CSS class used for the title label in a titlebar in
  * a toplevel window.
  *
  * Refer to individual widget documentation for used style classes.
  *
  * Since: 3.14
  */
 #define GTK_STYLE_CLASS_TITLE "title"
 
 /**
  * GTK_STYLE_CLASS_SUBTITLE:
  *
  * A CSS class used for the subtitle label in a titlebar in
  * a toplevel window.
  *
  * Refer to individual widget documentation for used style classes.
  *
  * Since: 3.14
  */
-#define GTK_STYLE_CLASS_SUBTITLE "subtitle"
+#define GTK_STYLE_CLASS_SUBTITLE "title"
 
 /**
  * GTK_STYLE_CLASS_NEEDS_ATTENTION:
  *
  * A CSS class used when an element needs the user attention,
  * for instance a button in a stack switcher corresponding to
  * a hidden page that changed state.
  *
  * Refer to individual widget documentation for used style classes.
  *
  * Since: 3.12
  */
 #define GTK_STYLE_CLASS_NEEDS_ATTENTION "needs-attention"
 
 /**
  * GTK_STYLE_CLASS_SUGGESTED_ACTION:
  *
  * A CSS class used when an action (usually a button) is the
  * primary suggested action in a specific context.
  *
  * Refer to individual widget documentation for used style classes.
  *
  * Since: 3.12
  */
 #define GTK_STYLE_CLASS_SUGGESTED_ACTION "suggested-action"
diff -U 25 -r -Z -B ./org/gtk/gtkwindow.c ./mod/gtk/gtkwindow.c
--- ./org/gtk/gtkwindow.c	2017-05-11 21:09:33.000000000 +0200
+++ ./mod/gtk/gtkwindow.c	2017-06-02 03:04:08.333733920 +0200
@@ -4098,50 +4098,51 @@
       visual = gdk_screen_get_rgba_visual (screen);
       if (!visual)
         return FALSE;
     }
 #endif
 
 #ifdef GDK_WINDOWING_WIN32
   if (GDK_IS_WIN32_DISPLAY (display))
     {
       if (!gdk_screen_is_composited (screen))
         return FALSE;
 
       /* We need a visual with alpha */
       visual = gdk_screen_get_rgba_visual (screen);
       if (!visual)
         return FALSE;
     }
 #endif
 
   return TRUE;
 }
 
 static void
 gtk_window_enable_csd (GtkWindow *window)
 {
+  return;
   GtkWindowPrivate *priv = window->priv;
   GtkWidget *widget = GTK_WIDGET (window);
   GdkVisual *visual;
 
   /* We need a visual with alpha for client shadows */
   if (priv->use_client_shadow)
     {
       visual = gdk_screen_get_rgba_visual (gtk_widget_get_screen (widget));
       if (visual != NULL)
         gtk_widget_set_visual (widget, visual);
 
       gtk_style_context_add_class (gtk_widget_get_style_context (widget), GTK_STYLE_CLASS_CSD);
     }
   else
     {
       gtk_style_context_add_class (gtk_widget_get_style_context (widget), "solid-csd");
     }
 
   priv->client_decorated = TRUE;
 }
 
 static void
 on_titlebar_title_notify (GtkHeaderBar *titlebar,
                           GParamSpec   *pspec,
                           GtkWindow    *self)
@@ -6045,50 +6046,51 @@
 
   titlebar = gtk_header_bar_new ();
   g_object_set (titlebar,
                 "title", priv->title ? priv->title : get_default_title (),
                 "has-subtitle", FALSE,
                 "show-close-button", TRUE,
                 NULL);
   context = gtk_widget_get_style_context (titlebar);
   gtk_style_context_add_class (context, GTK_STYLE_CLASS_TITLEBAR);
   gtk_style_context_add_class (context, "default-decoration");
 
   return titlebar;
 }
 
 void
 _gtk_window_request_csd (GtkWindow *window)
 {
   GtkWindowPrivate *priv = window->priv;
 
   priv->csd_requested = TRUE;
 }
 
 static gboolean
 gtk_window_should_use_csd (GtkWindow *window)
 {
+  return FALSE;
   GtkWindowPrivate *priv = window->priv;
   const gchar *csd_env;
 
   if (priv->csd_requested)
     return TRUE;
 
   if (!priv->decorated)
     return FALSE;
 
   if (priv->type == GTK_WINDOW_POPUP)
     return FALSE;
 
   csd_env = g_getenv ("GTK_CSD");
 
 #ifdef GDK_WINDOWING_BROADWAY
   if (GDK_IS_BROADWAY_DISPLAY (gtk_widget_get_display (GTK_WIDGET (window))))
     return TRUE;
 #endif
 
 #ifdef GDK_WINDOWING_WAYLAND
   if (GDK_IS_WAYLAND_DISPLAY (gtk_widget_get_display (GTK_WIDGET (window))))
     return TRUE;
 #endif
 
 #ifdef GDK_WINDOWING_MIR
@@ -9071,50 +9073,51 @@
   if (maximized)
     gtk_widget_set_sensitive (menuitem, FALSE);
   gtk_widget_show (menuitem);
   g_signal_connect (G_OBJECT (menuitem), "activate",
                     G_CALLBACK (ontop_window_clicked), window);
   gtk_menu_shell_append (GTK_MENU_SHELL (priv->popup_menu), menuitem);
 
   menuitem = gtk_separator_menu_item_new ();
   gtk_widget_show (menuitem);
   gtk_menu_shell_append (GTK_MENU_SHELL (priv->popup_menu), menuitem);
 
   menuitem = gtk_menu_item_new_with_label (_("Close"));
   gtk_widget_show (menuitem);
   if (!priv->deletable)
     gtk_widget_set_sensitive (menuitem, FALSE);
   g_signal_connect (G_OBJECT (menuitem), "activate",
                     G_CALLBACK (close_window_clicked), window);
   gtk_menu_shell_append (GTK_MENU_SHELL (priv->popup_menu), menuitem);
   gtk_menu_popup_at_pointer (GTK_MENU (priv->popup_menu), (GdkEvent *) event);
 }
 
 static void
 gtk_window_do_popup (GtkWindow      *window,
                      GdkEventButton *event)
 {
+  return;
   if (!gdk_window_show_window_menu (_gtk_widget_get_window (GTK_WIDGET (window)),
                                     (GdkEvent *) event))
     gtk_window_do_popup_fallback (window, event);
 }
 
 /*********************************
  * Functions related to resizing *
  *********************************/
 
 static void
 geometry_size_to_pixels (GdkGeometry *geometry,
 			 guint        flags,
 			 gint        *width,
 			 gint        *height)
 {
   gint base_width = 0;
   gint base_height = 0;
   gint min_width = 0;
   gint min_height = 0;
   gint width_inc = 1;
   gint height_inc = 1;
 
   if (flags & GDK_HINT_BASE_SIZE)
     {
       base_width = geometry->base_width;
